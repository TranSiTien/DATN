let's get into ch rule disclaimer you don't have to know ch root for using docker but understanding ch root will help you understand docker and i hope you will agree with me once i show you this thing here is the definition of chrome it's a ch root on a unix operating system is an operation that changes the apparent root directory for the currently running process and it's children all right it's a apparent root directory you you run an application it it knows what the root directory is right you have a root directory on your machine you can basically make it think that the root directory is something else right i'm going to give you a demo of this thing and you will understand what this is all right switch over here to my terminal window all right i'm running linux here right i'm going to tell you exactly what i'm running a bit later but you can guess what this is but i'm not going to give any spoilers now this is this is linux okay so i type ls and here is my uh directory i have two folders that i've prepared over here which is a ch root demo and ch root demo with ls okay so ch root demo contains three directories bin lib and lip64 this one also contains bin lib and lip64 so i don't know if i have tree here let's see cheers don't have three installs well i can just show you this thing see root demo so bin has one run executable called bash okay i have a lib folder which has a bunch of libraries these are libraries necessary for bash to run okay and there is also a lib 64 which is another file so this is actually common in linux runtime so we have when you install a program the executable goes to the bin directory and the libraries go to lib and lib64 directory it seems everything i'm telling you seems like very much linux internals but bear with me here this will make sense in a bit now what i've done here is i have copied the bash bash is basically a shell right bash is what you run commands it's it's a shell what i'm doing here is basically a shell right it's a prompt i can type something here and it runs it well guess what that is an application what i've done here is i've taken i've put that executable in the bin directory i've put the libraries in the lib and lib64 directory now every application in linux has this executable and libraries so you can find out what it is by typing ldd and then the the command flash bin slash dash and it will tell you well bash requires these libraries okay so these libraries are in lib you know these three files are in lib and this file is in lib64 so what i've done here is i've created this directory where i have just got the bash executable and the libraries required for bash to run okay so now what i can do here is i can do ch root i can run this command ch root ch root demo and then batch so what i'm saying is i'm saying hey i want a new shell to be created over here which thinks that this is the root directory okay remember the definition is ch root changes the apparent root directory for some process okay and now here that process is bash for bash change the apparent root directory to be this directory if i do this what happened i'm going to go one level back and run this so now what i have is a bash prompt i'm running bash but you notice here if i say the current working directory it says it's slash it thinks it's in root i'm actually in that ch root demo folder now but it doesn't think that it thinks it's in root right if i do ls i don't even have ls because guess what ls is another command right so what i have here is now i have a shell which doesn't do much because this let me exit this here okay so according to that shell this directory this directory is everything this directory is the entire operating system so i couldn't even run ls there right so i can get into that anytime and get out of it and now when i'm in that shell it thinks that this directory is the root and i get out of the shell now i'm in another shell which thinks which has a true idea of what root is okay does that make sense let me know if you have any questions i'm going to show you another another example okay so i have i have another directory which is um ch root with ls now here is what i've done i have copied over ls as well here okay we found that ls was missing i have copied over ls and i'm also copied over the libraries required for ls how do i do that again i do ldd ls what happened i thought led did i get the command wrong i have to do a slash bin slasher this ldd slash bin slash ls and now here are all the libraries required for ls all right so i've copied that over as well in this directory ch root with ls so i'm going to go one level back and i'm going to do ch root and to this directory ch root and let's put with ls and i'm going to start bash again and now again present working directory now i'm going to do ls now i have ls because i have copied that over in the bin directory now i can see that okay these are the three directories in the root okay this thing this is a root and these are the three directories you notice what i did then i basically tricked this process into thinking that it is in a root directory and these are all the files there are okay so if i were to exit here and now i'm in the in the main shell now let's say i do i create a new file all right so ch ch root with ls and i'm going to create hello txt alright i've created a file there and now if i do a list there i needed to do this all right so let me do this dot i'll load up txt that space ended up creating a file in the root okay so now i have me ch root with ls and this is what i wanted to do create a hello.txt file inside ch root with ls now i'm going to go back and now i'm going to do that ch root command again okay now i'm in this jailed shell and if i were to do ls you see it notices hello.txt hello txt is a part of its world view now because it's a file in that directory right that directory is all it knows about and cares about okay so this is basically a jailed shell i have managed to jail of a process in this case it's bash and give it a different worldview than what is actually reality okay now i cannot go anywhere out of there right if i were to do cd dot dot it's not gonna work that's pretty powerful right if if all you needed was file level isolation you wanted to make sure two processes are running and you don't want one process to mess with the files of another process you're good you don't need a vm now right if all you need is file isolation ch root is going to do it for you okay this is this is awesome now is it a way you can do something like this for the other considerations we talked about a bunch of considerations we talked about okay you need pi level isolation you need process level isolation you don't want one process to kill or even see other processes running in like another application but you also need resource level isolation you don't want runaway processors to consume ram or hard disk or whatever else well there are tools like this to provide a different world view for a single process right if you apply all of them together that process is going to be like i'm in a new machine right it doesn't know that it's actually running somewhere else because you've cut everything else off um this is commonly referred to as jailing and you see jailing very very often in a lot of different contexts for example if you run apps on your phone that's a good example of jailing you wouldn't expect like you have i i use an iphone i'm sure that's this is the same for an android as well you you cannot really expect an app to change a file in another app there is this guarantee that those two apps are separated out right that's basically jailing it's basically creating a different world view for this process so that process things it's somewhere else and you didn't really have to create a complete vm for it
Chúng ta không nhất thiết phải hiểu rõ về chroot để sử dụng Docker, nhưng hiểu chroot sẽ giúp bạn dễ dàng hình dung Docker hoạt động như thế nào. Và tôi hy vọng bạn sẽ đồng ý với tôi khi tôi giải thích xong vấn đề này.

Đầu tiên, hãy xem định nghĩa của chroot: Đây là một thao tác trong hệ điều hành Unix, thay đổi thư mục gốc (root directory) mà quá trình hiện tại và các tiến trình con của nó nhìn thấy. Cụ thể, nó sẽ thay đổi thư mục gốc mà ứng dụng đang chạy nghĩ rằng mình đang ở đâu.

Giờ tôi sẽ làm một ví dụ trực quan để bạn dễ hiểu. Tôi sẽ mở cửa sổ terminal và giải thích cho bạn.

Tôi đang chạy Linux, nhưng bạn có thể đoán thử xem. Tôi có hai thư mục đã chuẩn bị sẵn: chroot demo và chroot demo with ls. Trong đó, thư mục chroot demo chứa các thư mục con bin, lib, và lib64—các thư mục rất quan trọng trong môi trường Linux để lưu trữ các file hệ thống.

Ở thư mục chroot demo, tôi đã sao chép một ứng dụng shell có tên bash vào thư mục bin, cùng với các thư viện cần thiết trong lib và lib64. Khi tôi chạy lệnh ldd trên bash, nó sẽ liệt kê các thư viện mà bash cần. Tất cả những thư viện này tôi đã sao chép vào các thư mục đó.

Bây giờ, nếu tôi chạy lệnh chroot và chỉ định thư mục chroot demo làm thư mục gốc mới cho shell bash, bash sẽ nghĩ rằng thư mục này là root. Điều này có nghĩa là, khi tôi chạy bash trong môi trường đó, nó sẽ không nhìn thấy bất kỳ thứ gì bên ngoài thư mục này.

Ví dụ, khi tôi chạy lệnh ls, tôi sẽ không thấy gì cả, bởi vì bash chỉ biết thư mục gốc (root) của nó là thư mục chroot demo. Đây là một cách để "nhốt" bash vào một môi trường riêng biệt, và nó không thể biết hoặc truy cập các thư mục bên ngoài.

Giờ tôi sẽ làm thêm một ví dụ nữa. Ở thư mục chroot demo with ls, tôi đã sao chép thêm lệnh ls vào đó, cùng với các thư viện cần thiết. Khi tôi chạy lại lệnh chroot vào thư mục này và mở bash, tôi có thể chạy lệnh ls và thấy danh sách các thư mục bên trong chroot demo with ls. Tuy nhiên, mọi thứ vẫn chỉ giới hạn trong thư mục đó.

Điều thú vị ở đây là, tôi có thể tạo một tệp trong môi trường chroot demo with ls, và khi tôi thoát ra và chạy lại lệnh chroot, tệp tôi vừa tạo sẽ xuất hiện trong danh sách.

Cái này rất mạnh mẽ, vì tôi có thể "nhốt" một tiến trình (như bash) trong một môi trường riêng biệt, chỉ cho nó thấy một tập hợp các tệp và thư mục nhất định. Đây chính là cách chroot hoạt động, và nó có thể được sử dụng để cách ly các tiến trình mà không cần phải tạo một máy ảo hoàn toàn.

Cuối cùng, để bạn dễ hình dung, khi bạn sử dụng các ứng dụng trên điện thoại, bạn thấy rằng mỗi ứng dụng đều hoạt động độc lập với các ứng dụng khác, đúng không? Các ứng dụng không thể thay đổi tệp của nhau. Đó chính là cách jailing hoạt động, tạo ra một môi trường biệt lập cho mỗi ứng dụng.

Tương tự, Docker sử dụng các công cụ như vậy để tách biệt các ứng dụng ra khỏi nhau, giúp chúng hoạt động như thể đang ở trong một máy tính riêng biệt, nhưng thật ra chúng chia sẻ hệ thống tệp của cùng một máy chủ.

