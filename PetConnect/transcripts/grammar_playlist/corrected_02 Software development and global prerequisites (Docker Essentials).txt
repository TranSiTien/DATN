I want to start with one common problem when doing software development. Alright, we have a whole lot of problems we need to address in software development. This is probably among the top problems that we face. You must have come across a lot of situations where you encounter the "well, it runs on my machine" problem or an excuse, right? The developer works on an application, tests it out, works perfectly fine on their machine, they apply it somewhere else, and then it fails or doesn't quite work like they expect it to. It's like, "Yeah, well, it worked for me. I don't know what's going on, right?"

So, there's this concept of deterministic applications. When you build an application, you can kind of determine what the output will be, what the output should be, right? You write `System.out.println("Hello World")`, what do you expect? You expect that thing to print "Hello World" on the console, right? Looking at the application, you can determine what it'll do. So, by definition, when you run it repeatedly, it should result in the same output. That's what it means by deterministic applications. Well, you might say, "Well, you don't want it to do the same thing every time when different people use it; you want it to do different things, right?" But even that part needs to be deterministic. So, I guess a better term for it is predictable applications. You have an application that is predictable in what it does. 

So, what does it mean? It means that, first of all, it runs exactly the same from different environments to different management. You run it in dev, it works a certain way, you've tested it, which means that there should be a good guarantee that it works fine in QA. But there are a lot of times where things happen like, you know, in one environment, it works fine and then in another, it doesn't work fine, right? So, you want to make sure that it runs the same on all deployed instances as well. 

Alright, so one thing is from dev to QA to production, it needs to work the same way. And in production, you might have multiple deployed instances; it needs to work the same way in all those different instances, right?

Now, this is the goal, but then there are challenges to this. This doesn't quite work, right? Why does it not work? Well, typically, your application is more than just your source code, alright? So let's take an example like this. It's like this is a simple Java class, right? If you're a Java developer, this should be like Java 101; you start learning Java with this thing. All it does is print "Hello World," alright? Now, assume you take this class, you compile it, and in the directory that has the class file, you run `java Hello`. What do you think gets printed on the console? Well, prints "Hello World," yes, that's one option. It cannot find the class file, yes, that's another option. So, yeah, you would imagine that this prints "Hello World," right? But it could also print "Java not found in the path." That's another valid output. What do I mean by valid output? It's like you might have to expect that, well, Java might not be available in the path. Another thing, JRE might not be installed properly, alright? Java home, like, I guess this doesn't need Java home, but that's another problem. It could also result in an error which says "No permission to read the class file," right? So maybe the user that's running this command doesn't have read permission on that file. That's another problem, that is another possibility, right? And I could go on; there are lots of things that can possibly happen. So, it's not obvious that, well, this is going to print "Hello World," right? So, this is what I mean; our application is more than our source code; our application is also the environment in which it runs.

Okay, so we have a lot of processes to test our application. We've got dev, we have CI/CD, all the jazz for testing our application. Well, how about the environment? How can we test our environment? How can we make sure that that part is good too? Because that is a part of our deployed product, a part of our deployed application we take so much care for our code, but the environment is like, "Yeah, make sure all these things are installed and, well, let's hope for the best." Well, that's not really scalable, right? So, with our environment, if you think about it, what are the components involved? Well, we've got hardware resources